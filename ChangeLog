2007-04-07    <tino@firebird.03.softkill.net>

	* script/autostart.sh: Typo corrected (startd -> started)
	* script/autostart.sh (PATH): added in case it's used from cron

2007-03-31    <tino@firebird.03.softkill.net>

	* script/autostart.sh (for): Forgot to change echo into log

2007-03-26    <tino@firebird.03.softkill.net>

	* script/autostart.sh (log): added better logging
	(RUNDIR): in Shell && does not bind tighter than ||, fixed

	* ptybuffer.c (main, file_timestamp): pid reset to show correct
	PID after forks
	(file_timestamp): output corrrected to what it ought to be
	(main): logfile paths are now logged (in case realpath fails)

2007-02-26    <tino@firebird.03.softkill.net>

	* ptybuffer.c (file_open, file_flush_close, file_timestamp): added
	(file_out): timestamping added

2006-12-02    <tino@firebird.03.softkill.net>

	* ptybuffer.c (master_process, log_childstatus): logging made more
	clear

2006-11-11    <tino@firebird.03.softkill.net>

	* ptybuffer.c (main): realpath added to logfile and outfile.

2006-08-11    <tino@firebird.03.softkill.net>

	* ptybuffer.c: dirty.h removed, so changed all occurences of
	"dirty" names to the full name.
	(main): renamed HISTORY_LENGTH to PTYBUFFER_HISTORY_LENGTH
	(main): typo corrected which always gave "missing command" if
	option -c was not present.
	(daemonloop): now return void

2006-07-26    <tino@firebird.03.softkill.net>

	* ptybuffer.c (ptybuffer_new_fd, main): history_tail added (option -t)
	(main): options check (-c) and force (-f) added

2006-04-12    <tino@firebird.03.softkill.net>

	* ptybuffer.c (daemonloop): A little typo (wrong cb function) make
	ptybuffer segfault.  This shows that the abstraction level of
	tino/sock.h is not high enough yet.

2006-01-30    <tino@firebird.03.softkill.net>

	* ptybuffer.c (main, daemonloop, master_process): option -n hist

2005-06-04    <tino@firebird.03.softkill.net>

	* ptybuffer.c (connect_process): snprintf instead of sprintf

2004-11-12    <tino@firebird.03.softkill.net>

	* ptybuffer.c (main): SIGSEV corrected
	(main): more logging added and output clarified

2004-10-01    <tino@firebird.03.softkill.net>

	* ptybuffer.c (main): A lot of more options added.
	(file_out, file_log): Added logging at various places.

2004-09-20    <tino@firebird.03.softkill.net>

	* test.sh: set added, to see new environment variable
	PTYBUFFER_PID

	* ptybuffer.c: Option -d disabled daemonization, such that you can
	easily run programs under ptybuffer from /etc/inittab or similar.
	(master_process): Minor Bugfix (found at code review): When not
	all data could be delivered to the terminal at once, some data
	might have hung in ptybuffer until the next data block to the
	terminal was ready.  This bug is likely to trigger only if you
	transfer huge amounts of data to the terminal, which usually is
	not done.
	(main): put the current PID of ptybuffer into the environment as
	PTYBUFFER_PID, such that child processes know how to send signals
	there.

2004-05-23    <tino@firebird.03.softkill.net>

	* ptybuffer.c (main): cd /
	(sock_process, master_process, deamonloop): on close the socket is
	destroyed and freed, so I cannot check against the file
	descriptor.  Close-handling corrected.

2004-05-22    <tino@firebird.03.softkill.net>

	* ptybuffer.c: ECHO_SEND now is no more the default (it's stupid,
	"stty echo" and "stty -echo" are much better).

2004-05-21    <tino@firebird.03.softkill.net>

	* stress.sh: Well, there is a strange bug.  The stress.sh script
	only loops less than 1000 times.  Looking why.  Note that you need
	my "accept" to be reachable in path to use the stress script.
	Weird.  I cannot prove the problem under RedHat 9 on my 466 MHz
	Celeron develop machine.  However on one of my fast SuSE 9 servers
	it segfaults within seconds.  Oh well, thanks to gdb, I see
	.. it's a memory issue, realloc cores, sigh.  OK, setting
	environment variable MALLOC_CHECK_=1 shows that I have some
	serious memory corruption, hunting down .. Found with -lefence.

	* ptybuffer.c (master_process): on CLOSE we need to close the
	master, not free the user pointer.  Just cosmetic, as when the
	master closes everything will terminate anyway.

	* ChangeLog: started
